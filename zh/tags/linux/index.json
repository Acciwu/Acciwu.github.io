[{"content":"Linux基础 第一章 Linux的起源   Linux内核最初只是由芬兰人林纳斯-托瓦兹(Linus Torvalds)在上大学时编写的一个类Unix操作系统，同时也是Git的创始人\n  Linux的发行版\n  第二章 Linux的文件与目录结构   Linux中一切皆文件\n  第三章 VI和VIM编辑器   VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器\n  VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容\n  Vim下的非编辑模式\n  Vim下的编辑模式\n  Vim下的命令模式\n  第四章 网络配置 VMware的三种网络模式   Briged 桥接模式：桥接模式是通过虚拟网桥将主机上的网卡与虚拟交换机 VMnet0连接在一起，虚拟机上的虚拟网卡(并不是 VMware Network Adapter VMnet1和 VMware Network Adapter VMnet8)都连接在虚拟交换机VMnet0上，所以桥接模式的虚拟机必须与主机在同一网段且子网掩码，网关与DNS也要与主机网卡一致。虚拟机与宿主机和物理机处于同一个局域网中，可以和本局域网中的其它真实主机进行通讯（所以会占用局域网中的ip）。在桥接模式下，需要手工为虚拟系统配置IP地址、子网掩码，并且还要和宿主机器处于同一网段中。\n  NAT 网络地址转换模式：在NAT网络中，会用到VMware Network AdepterVMnet8虚拟网卡，主机上的VMware Network AdepterVMnet8虚拟网卡被直接连接到VMnet8虚拟交换机上与虚拟网卡进行通信。虚拟网卡只是作为主机与虚拟机通信的接口，并不是依靠虚拟网卡VMware Network AdepterVMnet8来联网的，它仍然依靠于宿主机器所在的网络来访问公网。NAT模式下虚拟机的TCP/IP配置信息是由VMnet8虚拟网卡的DHCPserver提供的，无法进行手工改动。该模式下，虚拟机可以和宿主机可以互相访问，但不可访问宿主机所在网络的其它计算机。采用NAT模式最大的优势是将虚拟系统接入互联网非常简单，只要求宿主机器能访问互联网即可，不需要配置IP地址、子网掩码、网关等，但DNS地址还是要根据实际情况填的。\n  Host-Only 仅主机模式：仅主机模式，是一种比NAT模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络，使用的虚拟网卡是VMnet1。仅主机模式的虚拟网卡仅对主机可见，并在虚拟机和主机系统之间提供网络连接。在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。\n  配置静态ip https://segmentfault.com/a/1190000011954814\n配置主机名   修改主机名\n1 2 3 4  #（功能描述：查看当前服务器的主机名称） hostname # 如果感觉此主机名不合适，我们可以进行修改。通过编辑/etc/hostname 文件 vim /etc/hostname     修改hosts映射文件\n1  vim /etc/hosts     第五章 系统管理   systemctl命令\n1 2 3 4 5 6 7 8 9 10 11 12 13  # systemctl基本格式 systemctl + start/stop/restart/status + service_name # 查看有哪些服务 cat /usr/lib/systemd/system # 防火墙服务 systemctl status firewalld systemctl stop firewalld systemctl start firewalld systemctl restart firewalld # 设置后台服务的自启配置 systemctl list-unit-files #查看服务开机启动状态 systemctl disable service_name #关掉指定服务的自动启动 systemctl enable service_name #开启指定服务的自动启动     关机重启命令\n1 2 3 4 5 6 7 8 9 10 11 12  # 将数据由内存同步到硬盘中  sync # 重启 reboot # 停机（不断电） halt # 计算机将在 1 分钟后关机，并且会显示在登录用户的当前屏幕中 shutdown -h 1 ‘This server will shutdown after 1 mins’ # 立马关机（等同于 poweroff） shutdown -h now # 系统立马重启（等同于 reboot） shutdown -r now     第六章 常用命令 帮助命令   man\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  NAME\t名称 SYNOPSIS\t简介 CONFIGURATION\t配置 DESCRIPTION\t描述 OPTIONS\t选项 EXIT STATUS\t退出码 RETURN VALUE\t返回值 ERRORS\t错误 ENVIRONMENT\t环境变量 FILES\t相关文件 VERSIONS\t版本 CONFORMING TO\t遵循的规则 NOTES\t注意事项 BUGS\t缺陷 EXAMPLE\t示例 AUTHORS\t作者 SEE ALSO\t拓展阅读 HISTORY\t维护历史     文件目录命令   常用命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  # print working directory 打印工作目录 pwd # list 列出目录内容 ls, ls -al, ll # Change Directory 切换路径 cd, cd -, cd .. # Make directory 建立目录(-p 多级创建) mkdir -p a/b/c/ # Remove directory 移除目录(-p 多级删除) rmdir -p a/b/c/ # cp -r递归复制整个文件夹 cp -r a/b/c/ ./ # rm 删除文件或目录 rm -r fileName # 递归删除目录中所有内容 rm -f fileName # 强制执行删除操作，而不提示用于进行确认 rm -v fileName # 显示指令的详细执行过程 # mv 移动或者重命名 # 查看文件 cat -n fileName more fileName less fileName # 输出内容到文件 echo \u0026#34;content\u0026#34; \u0026gt;\u0026gt; fileName # 输出文件头5行 head -n 5 # 输出文件尾部5行 tail -n 5 # 给原文件创建一个软链接 ln -s [原文件或目录] [软链接名]     时间日期命令   常用命令\n1 2 3 4 5 6  # 查看已经执行过历史命令 history # 查看日期 date # cal 查看日历 cal 2022     用户管理命令   常用命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # 添加用户 useradd [userName] # 设置用户密码 passwd [userName] # 删除用户 userdel [userName] # 删除用户和用户目录 userdel -r [userName] # 查看用户是否存在 id [userName] # 查看创建了哪些用户 cat /etc/passwd # 查看登录用户信息 who am i # 设置普通用户具有 root 权限, 添加 acciwu ALL=(ALL) ALL vi /etc/sudoers # Allow root to run any commands anywhere  root ALL=(ALL) ALL acciwu ALL=(ALL) ALL     用户组管理命令   常用命令\n1 2 3 4 5 6 7 8 9 10 11 12  # 新增组 groupadd [groupName] # 删除组 groupdel [groupName] # 修改组名 groupmod -n [newName] [oldName] # 添加新用户到某个组 useradd -g [groupName] [userName] # 修改用户组 usermod -g [groupName] [userName] # 查看创建了哪些组 cat /etc/group     文件权限命令   文件属性\n1 2 3 4 5 6 7 8 9  # chmod改变文件权限 chmod u+{r,w,x} [fileName] # user权限 chmod g+{r,w,x} [fileName] # group权限 chmod o+{r,w,x} [fileName] # other用户权限 chmod a+{r,w,x} [fileName] # all用户权限 chmod 777 fileName # 7：1+2+4编码分别代表r,w,r # chgrp改变文件所所属 chgrp [groupName] [fileName]     搜索查找命令   命令\n1 2 3 4 5 6  # 指定路径寻找 find [path] -name [\u0026#34;keyword\u0026#34;] # 首次必须执行 updatedb locate [\u0026#34;keyword\u0026#34;] # -n 显示行号 grep -n [\u0026#34;keyword\u0026#34;]     解压缩命令   命令\n1 2 3 4 5 6 7 8 9 10 11 12 13  # .gz文件 gzip [fileName] gunzip [fileName] # .zip文件 zip [fileName] unzip [fileName] -d [dirName] # .tar文件 # v 显示详细信息 # z 打包同时压缩 # x 解包.tar文件 # f 指定压缩后的文件名 tar -zcvf [fileName] tar -zxvf [fileName] [Path可选]     磁盘及分区命令   命令\n1 2  # disk usage 磁盘占用情况 du -h #显示目录下每个子目录的磁盘使用情况     命令\n1 2 3 4 5 6  # disk free 空余磁盘 df -h # 查看设备挂载情况 lsblk, lsblk -h # mount/umount 挂载/卸载 # fdisk -l 分区     进程管理命令   命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # process status 进程状态 ps ps aux | grep xxx #查看系统中所有进程 ps -ef | grep xxx #可以查看子父进程之间的关系 # kill终止进程, -9强制 kill [PID] kill [processName] # 查看进程树 pstree -p #显示进程的 PID pstree -u #显示进程的所属用户 # 实时监控系统进程状态 top # netstat 显示网络状态和端口占用信息 netstat -anp | grep 进程号 netstat –nlp | grep 端口号     系统定时命令   命令\n1 2 3 4 5 6 7  # crontab 服务管理 systemctl status crond systemctl restart crond # crontab 定时任务设置 crontab -e #编辑 crontab 定时任务,[* * * * * 执行的任务] crontab -l #查询 crontab 任务 crontab -r #删除当前用户所有的 crontab 任务     第七章 软件包管理 RPM  RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe 是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。  Yum仓库配置   YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS\n中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包\n并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次\n次下载、安装\n  在/etc/yum.repos.d/\u0026hellip;\n  ","description":"Linux内核最初只是由芬兰人林纳斯-托瓦兹(Linus Torvalds)在上大学时编写的一个类Unix操作系统，同时也是Git的创始人","id":2,"section":"posts","tags":["linux","shell"],"title":"Linux基础","uri":"https://acciwu.cn/zh/posts/2022/04/12/linux%E5%9F%BA%E7%A1%80/"},{"content":"第3章 JAVA的基本程序设计结构 3.1 Scanner 3.2 注释 3.3 变量与常量  变量必须以letter开头，java中的letter包括26个大小写字母，_ ，$，π 等表示字母的任何Unicode字符，不可使用 + 以及空格 java中定义常量必须携带 final 一个常量被 public 声明，则其他类的方法也可以调用 public static final double CM_PER_INCH = 2.54 Enumerated Types  3.4 操作数  整数除0抛出异常，但是浮点型除0则会得到Infinity或者NaN  3.5 类型转换   虚线转换有精度丢失，如int -\u0026gt; float\n1 2 3 4 5 6  /** 由此我们可以明白，实际上尾数确定了浮点数的精度，而数的大小主要是靠指数位，尾数只有23位，加上省略的那一位便是24位，所以如果int类型的值在2^24以内，float是可以精确表示的，但是当超过这个数的时候就不一定能精确表示了。 */ int n = 123456789; float m = n; System.out.println(m); // 1.23456792E8     运算符和操作数结合\n1 2 3 4  int x = 2; double y = 3.5; // x += y 等价于 x = int()(x + y) 结果为5 system.out.println(x + y) //向上转型为double, 结果为8.5     \u0026amp;\u0026amp; 和 \u0026amp;\n（E1 \u0026amp;\u0026amp; E2） 和 （E1 || E2） 采取“short circur”方式。 前者E1不成立则E2不执行，可避免： (x != 0) \u0026amp;\u0026amp; (1/x \u0026gt; 1)   3.6 字符串相等比较   a.equals(b)比较两字符串的值是否相等\n  a == b比较两字符串(引用类型)是否存储在同一位置，每个新new的对象内存地址都不同。\n1 2 3 4 5 6 7 8 9 10  /**\t== 判断的是两个对象是否相同 对于基本类型来说是值比较，对于引用类型来说是比较的是引用 hashcode值即使相同，两个对象也可以不相等 */ /** equals()没重写前本质是==； 重写后判断的是两个字符串变量的值是否相同（String类、Integer类等） * a==b为true时，a.equals(b)必定为true * a==b为false时，a.equals(b)也可能为true *\teqials不相同，hashcode也可能相同（hash冲突） */     C语言从不使用==来比较字符串，而是使用strcpinstead。Java方法compareTo与StrCMP完全类似\n  3.7 StringBuilder和StringBuffer  从较短的字符串中构建字符串，比如击键或文件中的单词。为此目的使用字符串连接是低效的。每次连接字符串时，都会构造一个newString对象，这既耗时又浪费内存，当使用StringBuilder StringBuilder类是在Java5中引入的。它的前身StringBuffer的效率稍低，但它允许多个线程添加或删除字符。  3.8 Scanner(System.in)   nextLine()返回的是Enter键之前的所有字符，它是可以得到带空格的字符串的。\n  nextInt()返回字符，残留回车\\n，故紧接着的nextLine()会直接遇到回车被消耗掉 ( nextInt() 之后加 nextLine() 可解决)\n  next()会自动消去有效字符前的空格，只返回输入的字符，不能得到带空格的字符串。（简单点说，next我只要字，nextLine我啥都要)\n  3.9 System.out.println()   System.out 是类名.静态字段\n1 2 3 4  public final class class System{ ... public final static PrintStream out = null; }     因为out是类型是PrintStream对象，也就是PrintStream类的一个实例，所以可以调用PrintStream类的print()方法。\n  第四章 对象与类   面向对象OOP（Obeject-Oriented Programming）\n  封装(encapsulation): 隐藏具体的实现方式，不能让类中的方法直接访问其他类的实例字段。程序只能通过invoke对象的方法与对象数据进行交互。\n  new Date()\n LocalDate.of(2022, 03, 03) 和 LocalDate.now()    一个类中只可以拥有一个public类，且类名同文件名\n  4.4 静态字段和静态方法   静态字段：所有的实例对象共享这一字段，只有一个副本，它只属于这个类而不属于任何实例对象\n  静态常量：public statci final double PI = 3.14159263...;\n  静态方法: 静态方法不能访问类的非静态实例字段，但可以访问静态字段。调用：类名.方法\n 静态方法没有this参数，非静态方法才有。在运行时数据区，在虚拟机栈的局部变量index=0的就是this变量    成员变量和类变量的区别：\n1、两个变量的生命周期不同\n成员变量随着对象的创建而存在，随着对象的回收而释放。\n静态变量随着类的加载而存在，随着类的消失而消失。\n2、调用方式不同\n成员变量只能被对象调用。\n静态变量可以被对象调用，还可以被类名调用。\n3、别名不同\n成员变量也称为实例变量。\n静态变量也称为类变量。\n4、数据存储位置不同\n成员变量存储在堆内存的对象中，所以也叫对象的特有数据。\n静态变量数据存储在方法区（JDK7之后移动到堆中）的静态区，所以也叫对象的共享数据。\n  1 2  成员变量（也称实例变量，属于每一个实例独有）不一定是静态变量，静态变量(也称类变量，属于类，对象共享)一定是成员变量 由static修饰的成员变量称为静态变量，其实质上就是一个全局变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰   4.5 方法参数  JAVA总是采用按值调用的，方法得到的是所有参数值的一个副本 方法可以改变对象参数的状态 方法不能让一个对象参数引用一个新的对象  (1) 变量的存储位置   基本数据类型的局部变量：栈帧的局部变量\n  基本数据类型的成员变量：随着new实例化对象，变量名和值存放在堆的实例变量里\n  基本数据类型的静态变量：JDK7之前存储在方法区中(永久代)，JDK7(永久代)及JDK8(元空间)之后和字符串常量都存放在堆区中\n  引用数据类型的存储：变量名存在栈中，变量值存储的是对象的地址，对象实例存放在堆中，通过存储在局部变量表中的【对象引用】定位到存储在堆区中的【对象实例信息】\n  (2) 值传递和引用传递   Java只有值传递实参传给形参的时候只是拷贝一份副本；如果是引用类型，副本对象所指向的地址同实参一样（一份数据，两个引用）\n  基本类型：\n 不同的方法，所以不同的栈帧，无论形参如何操作都不会影响原始内容    引用类型：\n  实参和形参保持同一对象地址，形参的操作会影响实参；\n  形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。\n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public class ValueAnd { String name = \u0026#34;ccwu\u0026#34;; char[] ch = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;}; public static void main(String[] args) { ValueAnd valueAnd = new ValueAnd(); func(valueAnd.name, valueAnd.ch); System.out.println(valueAnd.name); // ccwu  System.out.println(valueAnd.ch); // {\u0026#39;1\u0026#39;, \u0026#39;b\u0026#39;}  } public static void func(String name, char[] ch){ // 形参声明 String name，此时的声明和实参指向同一个对象地址  System.out.println(name.hashCode()); // 3048254  // 相当于 name = new String(\u0026#34;123\u0026#34;); 因为String类型的不可变性。刚开始副本name指向常量池中的\u0026#34;ccwu\u0026#34;，新new了对象之后指向常量池的\u0026#34;123\u0026#34;  name = \u0026#34;123\u0026#34;; // name = new String(\u0026#34;123\u0026#34;);  System.out.println(name.hashCode()); // 48690, 地址已经改变  ch[0] = \u0026#39;1\u0026#39;; } }   (3) 参考文章 4.6 对象构造  重载：java允许任何方法可以重载，而不只是构造器方法。  返回类型不是重载的一部分，即不允许名字相同、参数相同，返回值不同的两个方法存在   默认字段初始化：成员变量会在链接的prepare阶段初始化默认值，局部变量必须手动的声明。 无参构造器：默认提供，但是添加有参构造器必须的同时添加无参构造器 初始化块：调用构造器的具体步骤  调用构造器（可多级调用） 字段初始化为默认值（0，false，null） 执行构造器主体代码    第五章 继承(Inheritance) 5.1 类、超类、子类   定义子类：extends\n  覆盖方法：super，指示编译器 调用超类方法的特殊关键字\n  **子类构造器：**第一条语句使用super(args...)则显示的调用超类的构造器，如没有则自动调用超类的无参构造器sper();\n  **继承层次：**C++可以多重继承。JAVA只能单继承，但是可以多实现接口，以此达到目的。\n  final类和方法、字段： 如果将一个类声明为final，只有其中的方法能自动地成为final，字段不可以\n  **强制类型转换：**操作符 A instanceof B 返回ture时表示A对象能强制转换为B对象的类型，B继承了A，即A是B的超类\n  **抽象类：**抽象类里可以有非抽象方法，也可以都是非抽象方法。有抽象方法必须是抽象类。\n  private: 仅对本类可见 public: 对外可见 protect: 对本包和子类可见 不加修饰符: 对本包可见   5.2 Object所有类的超类  equals方法 hashCode()方法  5.3 泛型数组列表   声明数组列表\n1 2 3  ArrayList\u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;Integer\u0026gt;(); ArrayList\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); var list3 = new ArrayList\u0026lt;Integer\u0026gt;();     **动态扩展：**超出默认值长度后，新建x倍的数组列表，拷贝旧的到新的\n  5.4 对象包装器和自动装箱  装箱和拆箱是编译器的工作，而不是虚拟机  1 2 3 4  自动装箱： list.add(3) -\u0026gt; list.add(Integer.valueOf(3)) 自动拆箱： int n = list.get(i) -\u0026gt; int n = list.get(i).intValue();   5.5 参数数量可变的方法   print方法\n1 2 3 4  public PrintStream printf(String format, Object ... args) { return format(format, args); } System.out.printf(\u0026#34;%s\u0026#34;, \u0026#34;ccwu\u0026#34;);     5.6 枚举类   枚举类的构造器总是私有的\n  枚举类的成员方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package com.ccwu.code; import java.util.Arrays; enum Human{ YELLOW, BLACK, WHITE, BROWN; } public class EnumCode { public static void main(String[] args) { System.out.println(Human.BLACK.ordinal()); // 返回元素在枚举中的下标 输出1  Human s = Enum.valueOf(Human.class, \u0026#34;WHITE\u0026#34;); // s赋值为Human中的\u0026#34;WHITE\u0026#34;  System.out.println(s); //WHITE  Human[] values = Human.values();// 返回Human中所有元素，数组  System.out.println(Arrays.toString(values)); // [YELLOW, BLACK, WHITE, BROWN]  } }     5.7 反射   获取Class 类对象的三种方式\n1 2 3 4 5 6 7 8 9 10  //第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class clz = Class.forName(\u0026#34;java.lang.String\u0026#34;); //第二种，使用 .class 方法。 //这种方法只适合在编译前就知道操作的 Class。 Class clz = String.class; //第三种，使用类对象的 getClass() 方法。 String str = new String(\u0026#34;Hello\u0026#34;); Class clz = str.getClass();     反射获取类中的成员\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Class cl = Class.forName(\u0026#34;java.lang.String\u0026#34;) // 获取类的公共字段，包括超类的 Field[] fields = cl.getFields()Field[]; // 获取类的所有字段，不包括超类的 Field[] declaredFields = cl.getDeclaredFields(); // 获取类的公共方法，包括超类的 Method[] methods = cl.getMethods(); // 获取类的所有方法，不包括超类的 Method[] declaredMethods = cl.getDeclaredMethods(); // 获取类的公共构造器，包括超类的 Constructor\u0026lt;?\u0026gt;[] constructors = cl.getConstructors(); // 获取类的所有构造器，不包括超类的 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cl.getDeclaredConstructors();     反射更改类中受保护的成员\n1 2 3 4 5 6 7  Student stu = new Studeent(\u0026#34;\u0026#34;...); Class cl = stu.getClass(); f = cl.declaredField(\u0026#34;id\u0026#34;); // f 可以是字段、方法、构造器 f.setAccessible(true); // 覆盖java的访问机制，使得可以访问和修改private的类成员 f.get(objName); // 获取 f 的值 f.set(objName, newValue); // 更改 f 的值     第6章 接口,lambda表达式与内部类 6.1 接口   接口的概念：接口中的所有方法自动设置为public方法，绝不会有实例字段\n  接口的属性：与方法自动设置为public一样，字段总是自动设置 public static final\n  接口与抽象类：可以实现多接口，只能单继承一个类\n  接口中的静态方法和私有方法：\n 通常将静态方法放在实现类中 java9中，接口中的方法可以是私有的，可以是私有的静态方法或者实例方法    默认方法：default修饰，不强制实现类一定要重写默认方法\n  解决默认方法冲突：\n 超类和实现的接口有相同的方法时，实现类的超类优先 同时实现的接口有相同的方法时，实现类重写方法    Comparable和Comparator接口\n1 2 3 4 5 6 7 8 9  // Arrays类中的sort方法可以对 对象数组 进行排序，前提是该对象必须实现了Comparable接口 public interface Comparable\u0026lt;T\u0026gt;{ int compareTo(T other); } // Comparator接口 public interface Comparator\u0026lt;T\u0026gt;{ int compare(T first, T second); }     对一个字符串进行排序\n String类实现了Comparable，而且String.compareTo()方法可以按字典顺序比较字符串 现在假设我们想要按字符长度递增的顺序进行排序，String类不该是我们修改 所以我们可以新建一个LengthComparator类，让它实现Comparator接口，重写compare()方法，实例化对象作为比较器参数，从而实现字符长度递增的顺序进行排序  1 2 3 4 5 6  class LengthComparator implements Comparator\u0026lt;String\u0026gt;{ @Override public int compare(String first, String second){ return first.length() - second.length(); } }     对象克隆\n  clone方法是Object类的一个protected方法，要克隆的类必须实现Cloneable接口重写clone方法\n1 2 3 4  protected native Object clone() throws CloneNotSupportedException; /** Cloneable接口是不包含任何方法的！其实这个接口仅仅是一个标志，而且这个标志也仅仅是针对 Object类中clone()方法的，如果clone类没有实现Cloneable接口，并调用了Object的clone()方法（也就是调用了 super.Clone()方法），那么Object的clone()方法就会抛出CloneNotSupportedException异常。 */     **Object类的clone如何实现？**它对于要拷贝的对象一无所知，只能逐个字段进行拷贝。\n  如果字段是基本类型则没有任何问题；\n  如果是引用类型，那么拷贝的字段就会得到原对象相同的引用，导致原对象和克隆对象共享一些信息，牵一而动全身。\n  所以实现Cloneable接口后重写的clone方法需要自己实现引用字段的拷贝\n  重写clone方法不做修改默认是浅拷贝，在clone方法里自己实现引用字段的拷贝后是深拷贝，序列化对象也可以实现深拷贝。\n    6.2 Lambda表达式   表达式形式：() -\u0026gt; {}\n  方法引用\n  构造器引用\n  变量作用域\n 基本数据类型的局部变量用final修饰  Lambda表达式引用的局部变量必须是最终变量或实际上的最终变量，也就是说局部变量在被创建后不得被重新赋值。 Lambda表达式是一个语法糖，会被编译生成为当前类的一个私有方法，Lambda表达式内直接引用局部变量本质是一种隐式传参，编译时会自动将引用的局部变量放到参数列表中（Lambda方法多了个参数），而引用的实例变量并不需要放到参数列表，因为方法内可以直接引用。 那么造成直接引用的局部变量需要final修饰的原因应该和这种隐式传参有关。所以在Lambda中对参数重新赋值或者在方法中将局部变量重新赋值，对另一方都是没有影响的 它所能访问到的外部类中的各种变量都只是一份拷贝，因此为了防止你误以为能够直接修改外部类的变量，做了这样的设定。   函数式接口：只有一个抽象方法的接口，如Runnable接口\n  匿名内部类和Lambda表达式\n1 2 3 4 5  - Java Lambda表达式的一个重要用法是简化某些匿名内部类（Anonymous Classes）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖， - JVM内部是通过`invokedynamic指令`来实现Lambda表达式的 - Lambda表达式并不能取代所有的匿名内部类，只能用来取代函数接口（Functional Interface）的简写     Runnable创建线程\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 1.类先实现接口，再实例化改类 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt; 20; i++) { System.out.println(Thread.currentThread().getName()+\u0026#34; \u0026#34;+i); } } } class ThreadTest{ public static void main(String[] args){ MyRunnable mr = new MyRunnable(); Thread t = new Thread(mr,\u0026#34;测试线程\u0026#34;); t.start(); } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 2.匿名内部类 public class ThreadTest { public static void main(String[] args) { Runnable r = new Runnable() { @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;Thread: \u0026#34;+i); } } }; Thread t = new Thread(r,\u0026#34;测试线程\u0026#34;); t.start(); } }     1 2 3 4 5 6 7 8 9 10 11 12  // 3.Lambda表达式 class ThreadTest{ public static void main(String[] args) { Runnable r = () -\u0026gt; { for (int i = 0; i \u0026lt; 10; i++) System.out.println(\u0026#34;Thread: \u0026#34;+i); }; Thread t = new Thread(r,\u0026#34;测试线程\u0026#34;); t.start(); } }       6.3 内部类   https://www.cnblogs.com/dolphin0520/p/3811445.html\n  为什么需要使用内部类？\n1 2  - 内部类可以对同一个包中的其他类隐藏 - 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据     为什么内部类可以无条件的访问外部类的成员?\n1  虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，【所以成员内部类中的Outter this\u0026amp;0 指针便指向了外部类对象】，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this\u0026amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。     成员内部类\n  成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）\n  当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：outer.this.成员变量\n  创建内部类的实例\n1 2 3 4 5 6 7 8 9 10 11  public class Test { public static void main(String[] args) { //第一种方式：必须通过Outter对象来创建  Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //第二种方式：通过Outter的成员函数，其返回值就是内部类对象类型  Outter outter = new Outter(); Outter.Inner inner1 = outter.getInnerInstance(); } }       局部内部类\n 局部内部类就像是方法里面的一个局部变量，是不能有public、protected、private以及static修饰符的。    匿名内部类\n  调用函数，当参数是传入某个对象需要实现某个接口时。不用先定义该接口的实现类，然后再实例化这个实现类当做该参数。\n  匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。\n    静态内部类\n 静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。    6.4 Lambda VS 内部类   字符串按字典排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;dsa\u0026#34;); list.add(\u0026#34;asd\u0026#34;); list.add(\u0026#34;er\u0026#34;); // 匿名内部类 list.sort(new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }); // Lambda表达式 // list.sort((String a, String b) -\u0026gt; a.compareTo(b));  for (String s : list) { System.out.println(s); }     Lamdba表达式根本就不是匿名内部类的语法糖 ，也就是说Lambda表达式底层实现不是匿名内部类的实现方式，他们其实两个东西\n1 2 3 4 5 6 7 8  - 匿名内部类其实在编译的时候会生成一个类文件，命名以ClassName$数字的方式，所以要是Lamdba表达式底层也是由匿名内部类的方式实现的话，那肯定也会生成一个同样类似的内文件 - 然而Lambda表达式在编译的时候不会额外生成一个类文件，\t被编译生成当前类的一个`私有静态方` - `那Lamdba表达式是怎么实现的?` 1. lamdba表达式被编译生成当前类的一个私有静态方法 2. 在原调用Lamdba方法的地方编译成了一个invokedynamic指令（java7 JVM中增加了一个新的指令）调用，同时呢也生成了一个对应的BootstrapMethod 3. 当lamdba表达式被JVM执行，也就是碰到2中说到的invokedynamic指令，该指令引导调用LambdaMetafactory.metafactory方法，该方法返回一个CallSite实例 4. 而这个CallSite实例中的target对象，也就是直接引用到一个MethodHandle实例，而这个MethodHandle实例会调用到1中生成的静态方法，在上面的例子就是lambda$main$0这个方法，完成整个lamdba表达式的使用     6.5 服务加载器 6.6 代理 第7章 异常、断言和日志 7.1 错误处理  派生于Error类或RuntimeException类的异常称为“非检查型异常”，其他则是检查型checked异常   声明检查型异常  子类方法中声明的检查型异常不能比超类的更泛。子类方法可以抛出更具体的或者不抛出。 超类方法没有抛出任何检查型异常，子类方法不能throws抛出，但可以try-catch捕获异常。       Throwable类\n  无参构造\n1 2 3 4  // The fillInStackTrace() method is called to initialize the stack trace data in the newly created throwable. public Throwable() { fillInStackTrace(); //native }     有参构造\n1 2 3 4  public Throwable(String message) { fillInStackTrace(); detailMessage = message; }     成员方法\n1 2 3  public String getMessage() { return detailMessage; }       7.2 捕获异常   try-with-resources\n  try-with-resources会在编译的时候帮我们自动补全代码\n  使用了try-with-resources语句之后，有可能会出现两个异常，一个是try块里的异常，一个是调用close函数里抛出的异常\n1 2 3 4  - 如果在调用close函数时出现异常，被称为Suppressed Exceptions - try块的异常会抛出，而close抛出的异常会被“抑制” - Throwable有个addSuppressed函数可以把调用close函数时出现的异常保存在一个数组 - 可以调用getSuppressed方法查看”被抑制的异常“数组       7.3 使用异常的技巧 7.4 使用断言   断言的概念：断言机制允许在测试期间向代码中插入一些检查，而在生产代码中自动删除。\n1 2 3 4  // 如false，则抛出AssertionError异常 assert x\u0026gt;=0; // 如false，后面的表达式传入AssertionError对象的构造器，转为一个消息字符串 assert x\u0026gt;=0:\u0026#34;assert“ + x + ”失败\u0026#34;     启用和禁用断言\n 用户类：  启动 java -ea xxx 禁用 java -da xxx   系统类  启动 java -esa xxx      使用断言完成参数检查\n  使用断言提供假设文档\n  7.5 日志 第8章 泛型程序设计 8.1 为什么用泛型（省事）  泛型程序设计（generic programming） 类型参数（type parameter） 通配符类型（wildcard type）  8.2 定义简单泛型类  public class Pair\u0026lt;T\u0026gt;{ private T first; }  8.3 泛型方法   类型变量\u0026lt;T\u0026gt; 或者 \u0026lt;V\u0026gt; 放在修饰符的后面，方法返回类型的前面\n  public static \u0026lt;T\u0026gt; T method1(){ . . .return T;}\n  public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; method2(){ . . }\n  8.4 类型变量的限定   为保证类型安全，必要时会插入强制类型转换。\n1 2 3 4 5 6 7  // T只能是实现了Comparable接口，否则编译出错 T[] a = new T[10]; T smallest = a[0]; for(int i=1; i\u0026lt;a.length; ++i){ if(smallest.compareTo(a[i] \u0026gt; 0)) smallest = a[i]; }     表示T应该是限定类型的子类型：public static \u0026lt;T extends Comparable\u0026gt; void method3(){ . . .}\n  限定类型可以是类也可以是接口。可以限定多个接口，用 \u0026amp;分割，但只能extends一个类\n  8.5 反泛型代码和虚拟机 1 类型擦除   虚拟机中没有泛型，所以被编译后类型擦除\n  public class Pair\u0026lt;T\u0026gt;{ private T first; } \u0026mdash;\u0026raquo;\u0026gt; public class Pair\u0026lt;Object\u0026gt;{ private Object first; }\n  2 转换泛型表达式  方法返回值本来是 T ，经过类型擦除后为 Object ，调用该方法的时候等式右边会被强制转换为你声明的类型变量  3 转换泛型方法 4 调用遗留代码 8.6 限制与局限 Java泛型的局限性\n  不可以实例化类型变量的数组，不可以定义T[] array = new T[10];\n  不可以定义泛型类的数组，不可以定义Pair\u0026lt;String\u0026gt;[] pairs = new Pair\u0026lt;String\u0026gt;[10];\n  8.7 泛型类型的继承规则   Pair\u0026lt;S\u0026gt;与Pair\u0026lt;T\u0026gt;没有任何关系\n  泛型类可以扩展或者实现其他的泛型类\n  8.8 通配符类型 1 上界通配股 1 2 3 4 5  List\u0026lt;? extends Number\u0026gt; // 可以 List \u0026lt;Integer\u0026gt; ; List\u0026lt;Double\u0026gt; ; List\u0026lt;Number\u0026gt;;   2 下界通配符 1 2 3 4 5  List\u0026lt;? super Integer\u0026gt; // 可以 List \u0026lt;Integer\u0026gt; ; List\u0026lt;Number\u0026gt; ; List\u0026lt;Object\u0026gt;;   3 无界通配符   考虑下面的 printList 方法：\n1 2 3 4 5  public static void printList(List\u0026lt;Object\u0026gt; list) { for (Object elem : list) System.out.println(elem + \u0026#34; \u0026#34;); System.out.println(); }   printList 的目标是打印任何类型的列表，但是它无法实现这个目标 - 它仅打印一个 Object 实例列表; 它不能打印 List \u0026lt;Integer\u0026gt;、List \u0026lt;String\u0026gt;、List \u0026lt;Double\u0026gt; 等，因为它们不是 List \u0026lt;Object\u0026gt; 的子类型。 要写一个通用的 printList 方法，使用 List \u0026lt;?\u0026gt;\n1 2 3 4 5  public static void printList(List\u0026lt;?\u0026gt; list) { for (Object elem: list) System.out.print(elem + \u0026#34; \u0026#34;); System.out.println(); }     8.9 反射和类型 第9章 集合 9.1 Java集合框架 (1)集合的 接口与实现类 分离 (2)队列底层通常有两种实现方式  循环数组：循环数组要比链表效率更高 链表：循环数组有界，如果要收集的对象没有上限，最好使用链表  (3)Collection接口   集合的基本类型接口是Collection接口，两个基本方法\n1 2 3 4 5  public interface Collection\u0026lt;E\u0026gt; extends Iterable\u0026lt;E\u0026gt; { boolean add(E e); // 添加元素  Iterator\u0026lt;E\u0026gt; iterator(); // 返回 实现了Iterator接口的迭代器对象  //........ }     for each 循环，编译器会将循环转换为带有迭代器的循环\n  Collection接口extends了Iterable接口，所以标准库中的任何集合都有迭代器 iterator()方法，也就可以用 for each 循环遍历\n  (4.1)Iterator接口   集合实现类调用 iterator() 方法得到返回值类型为 Iterator接口，就可以使用该接口的方法\n  使用迭代器对象依次访问集合中的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  package java.util; import java.util.function.Consumer; public interface Iterator\u0026lt;E\u0026gt; { // 判断当前迭代器是否还有元素  boolean hasNext(); // 取下一个元素，就像有头结点的链表  E next(); // 删除元素  default void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } // 遍历迭代器的元素  default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } }     调用forEachRemaining()方法并且提供Lambda表达式\n1 2 3 4 5 6 7 8 9  Collection\u0026lt;String\u0026gt; vec = new Vector\u0026lt;\u0026gt;(); vec.add(\u0026#34;ccwu1\u0026#34;); vec.add(\u0026#34;ccwu2\u0026#34;); vec.add(\u0026#34;ccwu3\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = vec.iterator(); iterator.forEachRemaining( (ele) -\u0026gt; System.out.println(ele) );     (4.2)ListIterator接口   集合实现类调用 listIterator() 方法得到返回值类型为 ListIterator接口，就可以使用该接口的方法\n  继承了Iterator接口的三个方法，新增了其他方法，可以反向遍历链表\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public interface ListIterator\u0026lt;E\u0026gt; extends Iterator\u0026lt;E\u0026gt; { // 判断当前迭代器是否还有元素  boolean hasNext(); // 取后一个元素，就像有头结点的链表  E next(); // 删除元素  default void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } // 判断当前迭代器是否还有元素, 和hasNext()  boolean hasPrevious(); // 取前一个元素，和next()  E previous(); // 设置新值  void set(E e); // 增加元素  void add(E e); }   (5)泛型使用方法  Collection接口声明了很多有用的方法，所有的实现类都应该提供这些例行方法。 如果实现Collection接口的每个类都要提供如此多的例行方法，这将是一件很烦人的事情。为了能够更容易的实现这个接口，Java类库提供了一个抽象类AbstractCollection，它保持基础的size和iterator仍为抽象方法，但是实现了其他的例行方法。  1 2 3 4 5  public abstract class AbstractCollection\u0026lt;E\u0026gt; implements Collection\u0026lt;E\u0026gt; { public abstract Iterator\u0026lt;E\u0026gt; iterator(); public abstract int size(); // ..... }   9.2 集合框架中的接口 参考：Java集合框架概述【冰湖一角】\n  Java集合详细图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  1、所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 2、集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。 3、抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。 4、实现类：8个实现类（实线表示），对接口的具体实现。 5、Collection 接口是一组允许重复的对象。 6、Set 接口继承 Collection，集合元素不重复。 7、List 接口继承 Collection，允许重复，维护元素插入顺序。 8、Map接口是键－值对象，与Collection接口没有什么关系。 9、Set、List和Map可以看做集合的三大类： - List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。 - Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。 - Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。      Collection接口   Map接口  9.3 Collection -\u0026gt; List (1)LinkedList类（链表）   在Java中，所有链表实际上都是双向链表\n  尾插 LinkedList.add()\n  初代迭代器 \u0026mdash; Iterator接口\n  获取迭代器：LinkedList.iterator()，其返回值类型是Iterator接口\n  迭代器方法：hasnext()，next()，remove()\n    二代迭代器 \u0026mdash; ListIterator()接口 extends Iterator接口\n 获取迭代器：LinkedList.listItrator()，其返回值类型是ListIterator接口 迭代器方法：继承初代方法；新增两个可以反向遍历链表方法 E previous()， Boolean hasPrevious()；操作元素的方法 void set(E e)，void add(E e)    (2)ArrayList类（数组列表）  List接口的实现类，有两种访问元素的协议：  通过迭代器 （LinkedList） 通过get和set方法随机访问，不适用于链表，所以底层是数组（ArrayList）   ArrayList封装了一个动态再分配的对象数组 Vector的所有方法都是同步的，线程安全，但是相对来说比较耗时；只有一个线程访问的时候，应该用方法不同步但是速度快的ArrayList  9.3 Collection -\u0026gt; Set (1)HashSet类（散列表: 链表+数组）   底层原理\n HashSet底层完全就是在HashMap的基础上包了一层，只不过存储的时候value是默认存储了一个Object的静态常量，取的时候也是只返回key HashSet的唯一性保证是依赖与hashCode()和equals()两个方法，所以存入对象的时候一定要自己重写这两个方法来设置去重的规则。 因为底层是HashMap，而存储的又是key，所以没有get()方法来直接获取，只能遍历获取。    散列表\n1 2 3 4 5  - 链表和数组查找某个元素却又不知它的位置，需要访问所有元素，这将很费时。如果**不在意元素的顺序**，可以用**散列表**。 - 散列码是由对象的**实例字段**得出的一个整数，它们是由String类的`hashCode方法`产生的。 - 自定义类，实现自己的`hashCode方法`时，需要与`equals方法`兼容。即如果`a.equals(b)为true`，a与b必须有相同的散列码 - Java8中，桶满时会从链表转为平衡二叉树，以此提高查找性能 - 如果散列表太满，一般是超过了装填因子(默认是0.75)就会进行再散列，新建一个2倍桶数的表(标准类库使用的桶数是2的幂，默认是16)     (2)TreeSet类（红黑树）  底层原理  底层是基于TreeMap来实现的，所以底层结构也是红黑树，因为他和HashSet不同的是不需要重写hashCode()和equals()方法，因为它去重是依靠比较器来去重，因为结构是红黑树，所以每次插入都会遍历比较来寻找节点插入位置，如果发现某个节点的值是一样的那就会直接覆盖    9.4 Collection -\u0026gt; Queue (1)Queue接口   基本方法\n1 2 3 4 5 6 7 8  public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { boolean add(E e); // 队尾添加元素,如果满了会抛出异常  boolean offer(E e); // 队尾添加元素，如果满了返回false  E remove(); // 删除队头元素，如果队空就抛出异常  E poll(); // Retrieves and removes the head of this queue, or returns null if this queue is empty  E element(); // etrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty.  E peek(); // Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. }     实现类\n1 2 3  Queue\u0026lt;String\u0026gt; q1 = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;String\u0026gt; q2 = new ArrayDeque\u0026lt;\u0026gt;(); Queue\u0026lt;String\u0026gt; q3 = new PriorityQueue\u0026lt;\u0026gt;();     (2) Deque接口  双端队列（Double Ended Queue）    它的实现类有两个：\n1 2  Deque\u0026lt;String\u0026gt; d1 = new ArrayDeque\u0026lt;\u0026gt;(); Deque\u0026lt;String\u0026gt; d2 = new LinkedList\u0026lt;\u0026gt;();     (3)PriorityQueue类（小顶堆）  优先队列：元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前队列中最小的元素(优先级最高)  9.5 Map -\u0026gt; HashMap 1  它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 `HashMap最多只允许一条记录的键为null，允许多条记录的值为null`。`HashMap非线程安全`，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。     继承关系\n  底层实现【数组+链表+红黑树】\n  9.6 Map -\u0026gt; TreeMap 1  TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。`在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator`，否则会在运行时抛出java.lang.ClassCastException类型的异常。    继承关系  9.7 HashMap和TreeMap比较   HashMap:适用于在Map中插入、删除和定位元素。\n  Treemap:适用于按自然顺序或自定义顺序遍历键（key）。\n  HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap.\n  HashMap 非线程安全 TreeMap 非线程安全\n  HashMap的结果是没有排序的，而TreeMap输出的结果是排好序的。\n  1 2  在HashMap中通过get（）来获取value,通过put（）来插入value,ContainsKey（）则用来检验对象是否已经存在。 可以看出，和ArrayList的操作相比，HashMap除了通过key索引其内容之外，别的方面差异并不大。   心得  要用一个接口的功能，不一定是直接或间接的实现该接口。也可以是 声明一个接口变量（接口引用变量），“我们不能创建接口的对象，但我们可以得到”  ","description":"Java领域有影响力和价值的著作之一，由拥有20多年教学与研究经验的资深Java技术专家撰写(获Jolt大奖)，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评。第10版根据Java SE 8全面更新，同时修正了第9版中的不足，系统全面讲解了Java语言的核心概念、语法、重要特性和开发方法，包含大量案例，实践性强。","id":3,"section":"posts","tags":["java","javaSe"],"title":"Java核心技术卷轴笔记","uri":"https://acciwu.cn/zh/posts/java%E6%A0%B8%E5%BF%83%E5%8D%B7%E8%BD%B4i/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":4,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://acciwu.cn/zh/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":5,"section":"gallery","tags":null,"title":"Photo","uri":"https://acciwu.cn/zh/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":10,"section":"","tags":null,"title":"About","uri":"https://acciwu.cn/zh/about/"}]